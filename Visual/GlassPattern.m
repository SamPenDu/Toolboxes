function img = GlassPattern(Stim, WinDim, Noise)%img = GlassPattern(Stim, [WinDim, Noise])%% Draws a Glass pattern defined by the Stim. % % Parameters:%   Stim :      Stimulus structure with parameters for each element%   WinDim :    Width of the image (optional)%   Noise :     Luminance noise from normal distribution (optional)%% The struct Stim contains the parameters:%   Stim.N =         Number of elements in display%   Stim.Sigma =     Standard deviation of dots%   Stim.Lambda =    Dot separation%% And per element parameters in row vectors:%   Stim.X =         X-coordinates%   Stim.Y =         Y-coordinates%   Stim.Theta =     Orientation of dipoles%   Stim.Phase =     If negative produces anti-correlated dipoles%   Stim.Contrast =  Contrast of elements (optional, default = 1)%% Returns an image which can be displayed or saved to disk. %% find elements that are actually inside the stimulus spaceinels = find(abs(Stim.X) <= 1 & abs(Stim.Y) <= 1);% image dimensions in pixels if nargin < 2    WinDim = 400;    Noise = 0;elseif nargin < 3    Noise = 0;endimg = ones(WinDim, WinDim)/2 + randn(WinDim, WinDim)*Noise;% if size is the same in all elementsif length(Stim.Sigma) == 1    Stim.Sigma = ones(Stim.N,1) * Stim.Sigma;end% if separation is the same in all elementsif length(Stim.Lambda) == 1    Stim.Lambda = ones(Stim.N,1) * Stim.Lambda;end% size of actual image (depends on maximal Gabor size)winSize = WinDim + 4*max(Stim.Lambda) + 2;img = ones(winSize, winSize)/2 + randn(winSize, winSize)*Noise;% rendering the Gaborsfor i = inels'    % orientation in cartesian coordinates    xori = Stim.Lambda(i)/2 * cosd(-Stim.Theta(i));    yori = Stim.Lambda(i)/2 * sind(-Stim.Theta(i));    con1 = Stim.Contrast(i);    if Stim.Phase(i) < 0        con2 = -Stim.Contrast(i);    else        con2 = con1;    end        % GaussianDot(input image, sigma, phase, xpos, ypos)    img = GaussianDot(img, Stim.Sigma(i), ...  %Size of Gaussian         winSize/2 + round(Stim.X(i) * WinDim/2 + xori), ...  %X-coordinates        winSize/2 + round(Stim.Y(i) * WinDim/2 + yori), ...  %Y-coordinates        con1);    %contrast of element     img = GaussianDot(img, Stim.Sigma(i), ...  %Size of Gaussian         winSize/2 + round(Stim.X(i) * WinDim/2 - xori), ...  %X-coordinates        winSize/2 + round(Stim.Y(i) * WinDim/2 - yori), ...  %Y-coordinates        con2);    %contrast of element end